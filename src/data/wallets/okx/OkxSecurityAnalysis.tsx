import { CodeBlock } from '@/components/CodeBlock';
import Figure from '@/components/Figure';
import Title from '@/components/Title';
import Link from 'next/link';
import React from 'react';

export default function OkxSecurityAnalysis() {
  return (
    <div className="flex flex-col gap-2">
      <Title level={4}>Key Management</Title>
      <p>OKX wallet support 2 different key management options:</p>

      <Title level={5}>Standard HD Wallet</Title>
      <Figure src="/wallets/okx/okx_key_management_1.jpeg" />

      <Title level={5}>Responsibility</Title>
      <p>
        A single user is responsible for managing the private key (
        <code>secp256k1</code>
        key pair in this case). We’ll discuss the key generation process in
        detail in the <Link href={'#key_generation'}>next section</Link>.
      </p>

      <Title level={5}>Storage</Title>
      <p>
        where is the key stored in: - browsers - mobile devices (iOS, Android)
        The passkey is generated by the device’s Secure Enclave (in case of iOS
        devices) or similar modules (in case of Android devices). The passkey is
        locally stored on the device’s Secure Enclave (in case of iOS devices)
        or similar modules (in case of Android devices).
      </p>

      <Title level={5}>Access</Title>
      <p>
        The user can access Secure Enclave (in case of iOS devices) or similar
        modules (in case of Android devices) in order to perform different
        operations without the passkey ever leaving the Secure Enclave.
      </p>

      <Title level={5}>MPC Wallet</Title>
      <Figure src="/wallets/okx/okx_key_management_2.jpeg" />

      <Title level={5}>Responsibility</Title>
      <p>
        A single user is responsible for managing the private key (
        <code>secp256k1</code>
        key pair in this case). We’ll discuss the key generation process in
        detail in the <Link href={'#key_generation'}>next section</Link>.
      </p>

      <Title level={5}>Storage</Title>
      <p>
        where is the key stored in: - browsers - mobile devices (iOS, Android)
        The passkey is generated by the device’s Secure Enclave (in case of iOS
        devices) or similar modules (in case of Android devices). The passkey is
        locally stored on the device’s Secure Enclave (in case of iOS devices)
        or similar modules (in case of Android devices).
      </p>

      <Title level={5}>Access</Title>
      <p>
        The user can access Secure Enclave (in case of iOS devices) or similar
        modules (in case of Android devices) in order to perform different
        operations without the passkey ever leaving the Secure Enclave.
      </p>

      <Title level={4}>Account Management</Title>
      <p>
        Clave does not support Externally Owned Accounts (EOAs) but it does
        support Smart Contract Accounts (SCAs).
      </p>

      <Title level={5}>Clave’s SCA Implementation</Title>
      <p>
        Clave maintains their own{' '}
        <Link
          href="https://github.com/getclave/clave-contracts"
          target="_blank"
        >
          SCA implementation
        </Link>
        .
      </p>

      <Title level={5}>Registry</Title>
      <p>
        Clave maintains their own and{' '}
        <Link
          href="https://github.com/getclave/clave-contracts/blob/master/contracts/managers/ModuleManager.sol"
          target="_blank"
        >
          ModuleManager
        </Link>{' '}
        and{' '}
        <Link
          href="https://github.com/getclave/clave-contracts/blob/master/contracts/managers/HookManager.sol"
          target="_blank"
        >
          HookManager
        </Link>
        .
      </p>

      <Title level={5}>Modules</Title>
      <p>
        Clave also has 2 module implementations:{' '}
        <Link
          href="https://github.com/getclave/clave-contracts/blob/master/contracts/modules/recovery/SocialRecoveryModule.sol"
          target="_blank"
        >
          SocialRecoveryModule
        </Link>{' '}
        and{' '}
        <Link
          href="https://github.com/getclave/clave-contracts/blob/master/contracts/modules/recovery/CloudRecoveryModule.sol"
          target="_blank"
        >
          CloudRecoveryModule
        </Link>
        .
      </p>

      <ul className="list-disc px-4">
        <li>
          <b>
            <Link
              href="https://github.com/getclave/clave-contracts/blob/master/contracts/modules/recovery/SocialRecoveryModule.sol"
              target="_blank"
            >
              SocialRecoveryModule
            </Link>
          </b>
          : The Social recovery module allows clave users to assign guardians to
          their account who can help recovery your wallet.
          <CodeBlock
            code={`struct RecoveryConfig {
  uint128 timelock; // Recovery timelock duration
  uint128 threshold; // Recovery threshold
  address[] guardians; // Guardian addresses
}`}
            language="typescript"
          />
          <p>
            Each account has a <code>RecoveryConfig</code> which defines:
          </p>
          <ol className="list-decimal px-4">
            <li>
              <code>timelock</code> defines the duration of the recovery period
              (see recovery section for more context).
            </li>
            <li>
              <code>threshold</code> defines the minimum number of guardians
              that need to approve the recovery of an account. Note that the{' '}
              <code>threshold</code> will always be less than or equal to the
              number of <code>guardians</code> associated with the account.
            </li>
            <li>
              <code>guardians</code> is an array of guardian addresses
              associated with an account.
            </li>
          </ol>
          <p>
            We’ll discuss how this module is used for recovery in{' '}
            <Link href={'#account_recovery_process'}>this section</Link>.
          </p>
        </li>
        <li>
          <b>
            <Link
              href="https://github.com/getclave/clave-contracts/blob/master/contracts/modules/recovery/CloudRecoveryModule.sol"
              target="_blank"
            >
              CloudRecoveryModule
            </Link>
          </b>
          : The cloud recovery module recovers an account using a key stored in
          iCloud or other similar clouds.{' '}
          <b>
            This module is no longer used in the current Clave app because
            passkeys can sync with different user devices.
          </b>
        </li>
      </ul>

      <Title level={4}>Processes</Title>
      <p>OKX has the following processes in place:</p>
      <Title level={5} id="key_generation">
        Key generation
      </Title>
      <b>Case 1: Standard HD key based generation</b>
      <Figure src="/common/secp256k1/secp256k1_key_generation.jpeg" />
      <p>
        A random number selected from the secp256k1 elliptic curve serves as the
        private key. This key is then multiplied by a predefined point on the
        curve to generate the public key. The Ethereum address is derived from
        the last 20 bytes of the hashed public key. The &apos;seed phrase&apos;
        is usually introduced for human-readable backup, enabling the
        deterministic derivation of private and public keys.
      </p>

      <b>Case 2: MPC key generation</b>
      <Figure src="/wallets/okx/mpc_key_generation.jpeg" />
      <p>
        By creating a wallet, the OKX transforms a single private key into three
        separate shares. Share 1 is stored in the OKX server, share 2 is stored
        on user’s device local storage, and share 3 is generated by device,
        encrypted and can be backed up to the device’s preferred cloud services,
        like Google Cloud, iCloud and Huawei Cloud.
      </p>

      <Title level={5}>Transaction process</Title>
      <b>Case 1: EOA flow</b>
      <Figure src="/common/secp256k1/secp256k1_trx_sig.jpeg" />
      <p>
        <b>Signing Transactions</b>: A transaction, containing details such as
        nonce(a sequential number), amount, gas price, and recipient address, is
        signed using the private key. This process, involving the ECDSA, a
        digital signature algorithm that uses elliptic curve cryptography and
        adopts secp256k1 as the curve, generates a signature consisting of
        values (r, s, v). The signature and the original transaction are then
        broadcast on the network.
      </p>
      <Figure src="/common/secp256k1/eth_trx_verification.jpeg" />
      <p>
        <b>Verifying Transactions</b>: Once a transaction reaches Ethereum
        nodes, it undergoes a validation process in the node&apos;s mempool. To
        verify the signer, the nodes use the signature and hashed transaction to
        derive the sender&apos;s public key and confirm the transaction&apos;s
        authenticity by matching the derived address with the sender&apos;s.
      </p>

      <b>Case 2: SCA flow</b>
      <p>
        <b>Signing Transactions</b>: This follows a standard 4337 flow, where
        the user uses an EOA to sign user ops.
      </p>
      <p>
        <b>Verifying Transactions</b>: This also follows a standard 4337 flow,
        where the signed user ops and sent to a bundler which bundles the user
        ops to create bundles and sends them to the mempool as a normal ethereum
        transaction. This transaction invokes the <code>handleOps</code>{' '}
        function on the{' '}
        <Link
          href={
            'https://etherscan.io/address/0x5ff137d4b0fdcd49dca30c7cf57e578a026d2789'
          }
          target="_blank"
        >
          {' '}
          Entrypoint contract{' '}
        </Link>{' '}
        and the validity of the user op is checked using the{' '}
        <code>
          <Link
            href={
              'https://etherscan.io/address/0x5147ce3947a407c95687131be01a2b8d55fd0a40#writeContract%23F15'
            }
            target="_blank"
          >
            validateUserOp
          </Link>
        </code>
        function.
      </p>
      <Figure src="/common/erc_4337/4337_trx.png" />
      <figcaption style={{ textAlign: 'center' }}>
        An example 4337 style transaction (
        <Link
          href="https://etherscan.io/tx/0x870a39e139d4dbc7ee7c03a6678b3e6e10ce9b0c76f95bbf5c0d33887a6ec127"
          target="_blank"
        >
          source
        </Link>
        )
      </figcaption>

      <b>Case 3: MPC flow</b>
      <Figure src="/wallets/okx/mpc_key_generation.jpeg" />
      <p>
        <b>Signing Transactions</b>: When signing a transaction, individual
        parties (in this case, OKX and user’s device) generate partial
        signatures or &apos;signature shares&apos; using their secret shares (in
        this case, share 1 and share 2). These signature shares are then
        combined to produce a single final signature. The process of combination
        is typically handled by the TSS protocol and ensures that the final
        signature is valid for the original message as if it was signed by a
        single private key. This way, the TSS allows for a distributed way of
        signing a message without ever reconstructing the entire private key.
        You can refer to the documentation for more specific implementation
        details{' '}
        <Link
          href={
            'https://github.com/okx/threshold-lib/blob/main/docs/Threshold_Signature_Scheme.md'
          }
          target="_blank"
        >
          {' '}
          here{' '}
        </Link>
        .
      </p>
      <p>
        <b>Verifying Transactions</b>: Once the transaction message is signed,
        it’s sent to the mempool just as any other EOA signed transaction.
      </p>
      <Figure src="/common/secp256k1/eth_trx_verification.jpeg" />
      <p>
        Once a transaction reaches Ethereum nodes, it undergoes a validation
        process in the node’s mempool. To verify the signer, the nodes use the
        signature and hashed transaction to derive the sender’s public key and
        confirm the transaction’s authenticity by matching the derived address
        with the sender’s.
      </p>

      <Title level={5} id="account_recovery_process">
        Account Recovery process
      </Title>

      <b>
        Method 1: Restore keyless (MPC) wallet: Restore MPC wallet with your
        exchange account
      </b>
      <Figure src="/wallets/okx/mpc_key_generation.jpeg" />
      <p>
        It’s highly recommended to back up your Share 3 to your device’s cloud
        (iCloud, Google Drive, or Huawei Cloud) to prevent the loss of your
        assets. To back up your Share 3 data, go to your device’s cloud service
        and set your password for encryption. Share 3’s data will be uploaded to
        your device’s cloud and it’ll be removed from your device to secure your
        private key shares.
      </p>
      <p>
        If you didn’t backup your Share 3’s data to your device’s cloud and your
        device is lost, you can’t access your assets permanently as you only
        have Share 1 remaining on your wallet’s server.
      </p>
      <p>
        Once you have backed up Share 3, you can recover your MPC account if you
        lose the access to your device with Share 2.
      </p>
      <p>
        You can restore your wallet via cloud backup using Share 1 and Share 3
        data even if you have lost your device. All the 3 secret codes will be
        reset to secure your asset and prevent the risk of Share 2 data being
        leaked. It’ll not affect your wallet address or your assets.
      </p>

      <b>
        Method 2: Cloud backup: Get seed phrase from cloud backup to restore
        wallets
      </b>
      <p>TODO(vasa): Explain further</p>

      <b>
        Method 3: Seed Phrase: 12, 15, 18, 21, 24-worded seed phrases are
        supported
      </b>
      <p>TODO(vasa): Explain further</p>

      <b>Method 4: Hardware wallet: Connect hardware wallets via bluetooth</b>
      <p>TODO(vasa): Explain further</p>

      <b>Method 5: Private key: Paste or enter private key</b>
      <p>TODO(vasa): Explain further</p>

      <Title level={5}>Migrating from another wallet</Title>
      <p>
        You can migrate to okx wallet in following ways
        <ul className="list-disc pl-4">
          <li>import seed phrase (seed format supported: 12/18/24)</li>
          <li>import private key</li>
          <li>Hardware wallet</li>
        </ul>
      </p>

      <Title level={5}>Migrating to another wallet</Title>
      <b>Case 1: EOA wallet</b>

      <p>
        You can export your private key/seed phrase and import that to any other
        compatible wallet.
      </p>

      <b>Case 2: SCA wallet</b>

      <p>
        You should be able to transfer all your assets to any other address in a
        single transaction.
      </p>

      <b>Case 3: MPC wallet</b>

      <p>
        Unfortunately, you cannot export the keyless wallet to any other wallet
        directly. The MPC algorithm is not yet supported by institutional-level
        security devices, and the majority of keyless wallets are customized.
        Since you have two private key shares, you may utilize Shares 2 and 3 to
        retrieve the entire private key without the assistance of OKX. The
        keyless wallet will then be transformed into a traditional wallet that
        is managed by a private key or seed phrase, which can subsequently be
        imported to other wallets. Your keyless wallet in the OKX App will no
        longer be valid following this procedure in order to avoid any liability
        conflicts.
      </p>

      <Title level={5}>
        What happens to the wallet if okx servers/platform is down?
      </Title>
      <b>Case 1: EOA wallet</b>

      <p>
        You should be able to access your wallet and the assets within it even
        if the okx platform is down.
      </p>

      <b>Case 2: SCA wallet</b>

      <p>
        You should be able to access your wallet and the assets within it even
        if the okx platform is down.
      </p>

      <b>Case 3: MPC (keyless) wallet</b>

      <p>
        Your assets in the keyless wallet will be safe if OKX is unavailable.
        When creating a keyless wallet, the private key is split into three
        pieces and stored on the OKX server, a user device, and either iCloud or
        Google Drive. You can obtain the full signature and use the wallet by
        using two of the private key shares when signing the transaction.
      </p>

      <p>
        If OKX or other platforms are unavailable, you can utilize the
        &apos;Emergency escape&apos; function to recover the entire private key
        by using Shares 2 and 3 of the private key, which will allow you to
        restore the wallet and transfer assets. The initial keyless wallet will
        no longer be valid at this time; instead, it will be changed into a
        conventional wallet that is managed by the private key.
      </p>
    </div>
  );
}
